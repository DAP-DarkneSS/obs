--- src/Map/CMapImageGenerator.cpp.orig	2012-03-25 22:05:40.821553529 +0300
+++ src/Map/CMapImageGenerator.cpp	2012-03-26 20:21:30.033000040 +0300
@@ -54,7 +54,7 @@
 	int Det = det(p1,p2,p3);
 	if (Det > 0)
 		return 0;
-	if (Det < 0) // Po prawej
+	else
 		return 1;
 }
 
@@ -99,7 +99,7 @@
 	}
 
 	// Posortuj mapy dla algorytmu generowania otoczki
-	map<string, vector<std::string>>::iterator j = schemes.begin();
+	map<string, vector<std::string> >::iterator j = schemes.begin();
 	for(; j != schemes.end(); j++)
 	{
 		std::vector<std::string>& Maps = j->second;
@@ -140,7 +140,7 @@
 			PositionAlphaStruct* Data = DataStructs[i];
 			Data->Position = Data->Position - CenterVector;
 			Vector2f& P = Data->Position;
-			float D = abs(P.x) + abs(P.y);
+			float D = fabs(P.x) + fabs(P.y);
 
 			if ((P.x >= 0) && ( P.y >= 0))
 				Data->Alpha = P.y/D;
@@ -149,10 +149,10 @@
 				Data->Alpha = 2 - P.y/D;
 			else 
 			if ((P.x < 0) && (P.y < 0))
-				Data->Alpha = 2 + abs(P.y)/D;
+				Data->Alpha = 2 + fabs(P.y)/D;
 			else
 			if ((P.x >= 0) && (P.y < 0))
-				Data->Alpha = 4 - abs(P.y)/D;
+				Data->Alpha = 4 - fabs(P.y)/D;
 
 		}
 		
@@ -402,7 +402,8 @@
 		float Rand = RandomPercent(25, 75);
 
 		// Jeœli punkt wygenerowa³ siê blisko koñca daj mu 15 d³ugoœci
-		float OldLengthSquared = DistanceSquared(OldVector, Vector2f(0, 0));
+		Vector2f tomat(0,0);
+		float OldLengthSquared = DistanceSquared(OldVector, tomat);
 		float QuaterLength = HalfDistance/2;
 		if(OldLengthSquared < QuaterLength * QuaterLength)
 		{
@@ -509,7 +510,9 @@
 
 void CMapImageGenerator::GeneratePaths(CWorldGraphExitEx &Exit)
 {		
-	GeneratePathBetweenTwoExits(Vector2f(Exit.FirstParent->mapPos.x * Proportion.x, Exit.FirstParent->mapPos.y * Proportion.y), Vector2f(Exit.SecondParent->mapPos.x * Proportion.x, Exit.SecondParent->mapPos.y * Proportion.y), Exit);
+	Vector2f tomat1(Exit.FirstParent->mapPos.x * Proportion.x, Exit.FirstParent->mapPos.y * Proportion.y);
+	Vector2f tomat2(Exit.SecondParent->mapPos.x * Proportion.x, Exit.SecondParent->mapPos.y * Proportion.y);
+	GeneratePathBetweenTwoExits(tomat1, tomat2, Exit);
 	Exit.PathCreated = true;
 }
 
