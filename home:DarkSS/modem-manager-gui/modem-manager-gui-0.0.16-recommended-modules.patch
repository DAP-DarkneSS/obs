diff -crB modem-manager-gui-0.0.16/src/main.c modem-manager-gui-0.0.16.new/src/main.c
*** modem-manager-gui-0.0.16/src/main.c	2013-07-20 19:29:34.000000000 +0400
--- modem-manager-gui-0.0.16.new/src/main.c	2013-07-28 00:31:30.000000000 +0400
***************
*** 378,385 ****
  struct _mmgui_cli_options {
  	gboolean invisible;
  	gboolean minimized;
! 	gboolean nostatistics;
! 	gboolean nosmsupdate;
  	//SMS
  	gboolean concatsms;
  	gboolean smsexpandfolders;
--- 378,385 ----
  struct _mmgui_cli_options {
  	gboolean invisible;
  	gboolean minimized;
! 	/*gboolean nostatistics;
! 	gboolean nosmsupdate;*/
  	//SMS
  	gboolean concatsms;
  	gboolean smsexpandfolders;
***************
*** 408,413 ****
--- 408,414 ----
  	mmgui_main_window_t window;
  	mmgui_cli_options_t options;
  	mmgui_traffic_limits_t limits;
+ 	mmgui_core_options_t coreoptions;
  	//Objects
  	mmguicore_t core;
  	settings_t settings;
***************
*** 560,565 ****
--- 561,567 ----
  static void mmgui_main_application_terminate(mmgui_application_t mmguiapp);
  static void mmgui_main_application_activate_signal(GtkApplication *application, gpointer data);
  static void mmgui_main_application_shutdown_signal(GtkApplication *application, gpointer data);
+ static void mmgui_main_modules_enum_callback(enum _mmgui_module_type type, gchar *name, gchar *description, gboolean applicable);
  #ifdef __GLIBC__
  static void mmgui_main_application_backtrace_signal_handler(int sig, siginfo_t *info, ucontext_t *ucontext);
  #endif
***************
*** 5728,5734 ****
  			/*Add main window to application window list*/
  			gtk_application_add_window(GTK_APPLICATION(application), GTK_WINDOW(mmguiapp->window->window));
  			/*Core object*/
! 			mmguiapp->core = mmguicore_new(mmgui_main_event_callback, mmguiapp->limits, mmguiapp);
  			if (mmguiapp->core == NULL) {
  				mmgui_main_application_unresolved_error(mmguiapp, _("Error while initialization"), _("No one modem manager is available"));
  				return;
--- 5730,5736 ----
  			/*Add main window to application window list*/
  			gtk_application_add_window(GTK_APPLICATION(application), GTK_WINDOW(mmguiapp->window->window));
  			/*Core object*/
! 			mmguiapp->core = mmguicore_new(mmgui_main_event_callback, mmguiapp->limits, mmguiapp->coreoptions, mmguiapp);
  			if (mmguiapp->core == NULL) {
  				mmgui_main_application_unresolved_error(mmguiapp, _("Error while initialization"), _("No one modem manager is available"));
  				return;
***************
*** 5795,5800 ****
--- 5797,5824 ----
  	gmm_settings_close(mmguiapp->settings);
  }
  
+ static void mmgui_main_modules_enum_callback(enum _mmgui_module_type type, gchar *name, gchar *description, gboolean applicable)
+ {
+ 	if ((name != NULL) && (description != NULL)) {
+ 		/*New module*/
+ 		g_printf("%3s %15s | %s\n", applicable ? "[+]" : "[-]", name, description);
+ 	} else {
+ 		/*New module type*/
+ 		switch (type) {
+ 			case MMGUI_MODULE_TYPE_MODEM_MANAGER:
+ 				g_printf(_("Modem management modules:\n"));
+ 				g_printf("    %15s | %s\n", _("Module"), _("Description"));
+ 				break;
+ 			case MMGUI_MODULE_TYPE_CONNECTION_MANGER:
+ 				g_printf(_("Connection management modules:\n"));
+ 				g_printf("    %15s | %s\n", _("Module"), _("Description"));
+ 				break;
+ 			default:
+ 				break;
+ 		}
+ 	}
+ }
+ 
  #ifdef __GLIBC__
  static void mmgui_main_application_backtrace_signal_handler(int sig, siginfo_t *info, ucontext_t *ucontext)
  {
***************
*** 5834,5839 ****
--- 5858,5864 ----
  {
  	mmgui_application_t mmguiapp;
  	GOptionContext *optcontext;
+ 	gboolean listmodules;
  	GError *error;
  	gint status;
  	
***************
*** 5841,5850 ****
  	mmguiapp->options = g_new0(struct _mmgui_cli_options, 1);
  	mmguiapp->window = g_new0(struct _mmgui_main_window, 1);
  	mmguiapp->limits = g_new0(struct _mmgui_traffic_limits, 1);
  	
  	//Predefined CLI options
  	GOptionEntry entries[] = {
! 		{ "invisible",    'i', 0, G_OPTION_ARG_NONE, &mmguiapp->options->invisible,    _("Do not show window on start"), NULL },
  		//{ "nostatistics", 'n', 0, G_OPTION_ARG_NONE, &mmguiapp->options->nostatistics, "Disable traffic statistics", NULL },
  		//{ "nosmsupdate",  's', 0, G_OPTION_ARG_NONE, &mmguiapp->options->nosmsupdate,  "Disable sms update", NULL },
  		{ NULL }
--- 5866,5885 ----
  	mmguiapp->options = g_new0(struct _mmgui_cli_options, 1);
  	mmguiapp->window = g_new0(struct _mmgui_main_window, 1);
  	mmguiapp->limits = g_new0(struct _mmgui_traffic_limits, 1);
+ 	mmguiapp->coreoptions = g_new0(struct _mmgui_core_options, 1);
+ 	
+ 	/*Default options*/
+ 	mmguiapp->options->invisible = FALSE;
+ 	mmguiapp->coreoptions->mmmodule = NULL;
+ 	mmguiapp->coreoptions->cmmodule = NULL;
+ 	listmodules = FALSE;
  	
  	//Predefined CLI options
  	GOptionEntry entries[] = {
! 		{ "invisible",   'i', 0, G_OPTION_ARG_NONE,   &mmguiapp->options->invisible,    _("Do not show window on start"), NULL },
! 		{ "mmmodule",    'm', 0, G_OPTION_ARG_STRING, &mmguiapp->coreoptions->mmmodule, _("Use specified modem manager module"), NULL },
! 		{ "cmmodule",    'c', 0, G_OPTION_ARG_STRING, &mmguiapp->coreoptions->cmmodule, _("Use specified connection manager module"), NULL },
! 		{ "listmodules", 'l', 0, G_OPTION_ARG_NONE,   &listmodules,                     _("List all available modules"), NULL },
  		//{ "nostatistics", 'n', 0, G_OPTION_ARG_NONE, &mmguiapp->options->nostatistics, "Disable traffic statistics", NULL },
  		//{ "nosmsupdate",  's', 0, G_OPTION_ARG_NONE, &mmguiapp->options->nosmsupdate,  "Disable sms update", NULL },
  		{ NULL }
***************
*** 5893,5898 ****
--- 5928,5945 ----
  	
  	g_option_context_free(optcontext);
  	
+ 	if (listmodules) {
+ 		/*Modules listing*/
+ 		mmguicore_modules_list(mmguiapp->coreoptions, mmgui_main_modules_enum_callback);
+ 		/*Exit*/
+ 		g_free(mmguiapp->coreoptions);
+ 		g_free(mmguiapp->options);
+ 		g_free(mmguiapp->window);
+ 		g_free(mmguiapp->limits);
+ 		g_free(mmguiapp);
+ 		return EXIT_SUCCESS;
+ 	}
+ 	
  	//Run GTK+ application
  	mmguiapp->gtkapplication = gtk_application_new("org.gtk.ModemManagerGUI", 0);
  		
***************
*** 5916,5921 ****
--- 5963,5977 ----
  	if (mmguiapp->limits != NULL) {
  		g_free(mmguiapp->limits);
  	}
+ 	if (mmguiapp->coreoptions != NULL) {
+ 		if (mmguiapp->coreoptions->mmmodule != NULL) {
+ 			g_free(mmguiapp->coreoptions->mmmodule);
+ 		}
+ 		if (mmguiapp->coreoptions->cmmodule != NULL) {
+ 			g_free(mmguiapp->coreoptions->cmmodule);
+ 		}
+ 		g_free(mmguiapp->coreoptions);
+ 	}
  	if (mmguiapp != NULL) {
  		g_free(mmguiapp);
  	}
diff -crB modem-manager-gui-0.0.16/src/mmguicore.c modem-manager-gui-0.0.16.new/src/mmguicore.c
*** modem-manager-gui-0.0.16/src/mmguicore.c	2013-07-19 00:39:37.000000000 +0400
--- modem-manager-gui-0.0.16.new/src/mmguicore.c	2013-07-28 00:10:16.000000000 +0400
***************
*** 18,23 ****
--- 18,24 ----
   */
  
  #include <glib.h>
+ #include <glib/gi18n.h>
  #include <gmodule.h>
  #include <gio/gio.h>
  #include <string.h>
***************
*** 32,37 ****
--- 33,42 ----
  #include "netlink.h"
  #include "resources.h"
  
+ #define MMGUI_MODULE_FILE_PREFIX         '_'
+ #define MMGUI_MODULE_FILE_EXTENSION      ".so"
+ #define MMGUI_MODULE_FILE_EXTENSION_LEN  3
+ 
  #define MMGUI_MIN_SMS_NUMBER_LENGTH      3
  #define MMGUI_MAX_SMS_NUMBER_LENGTH      20
  
***************
*** 40,45 ****
--- 45,55 ----
  
  #define MMGUI_THREAD_STOP_CMD            0x00
  
+ enum _mmgui_core_dbus_start_reply_status {
+ 	MMGUI_CORE_DBUS_START_REPLY_ALREADY_RUNNING 	= 2,
+ 	MMGUI_CORE_DBUS_START_REPLY_SUCCESS 	        = 1
+ };
+ 
  gboolean mmguicore_devices_add(mmguicore_t mmguicore, mmguidevice_t device);
  gboolean mmguicore_devices_remove(mmguicore_t mmguicore, guint deviceid);
  gboolean mmguicore_devices_close(mmguicore_t mmguicore);
***************
*** 153,158 ****
--- 163,234 ----
  	
  }
  
+ static gboolean mmguicore_system_services_activate(gchar *interface, guint *status)
+ {
+ 	GDBusConnection *connection;
+ 	GDBusProxy *proxy;
+ 	gboolean res;
+ 	GVariant *statusv;
+ 	GError *error;
+ 		
+ 	if (interface == NULL) return FALSE;
+ 	
+ 	error = NULL;
+ 	
+ 	connection = g_bus_get_sync(G_BUS_TYPE_SYSTEM, NULL, &error);
+ 	
+ 	if ((connection == NULL) && (error != NULL)) {
+ 		g_printf("Core error: %s\n", error->message);
+ 		g_error_free(error);
+ 		return FALSE;
+ 	}
+ 	
+ 	error = NULL;
+ 	
+ 	proxy = g_dbus_proxy_new_sync(connection,
+ 									G_DBUS_PROXY_FLAGS_NONE,
+ 									NULL,
+ 									"org.freedesktop.DBus",
+ 									"/org/freedesktop/DBus",
+ 									"org.freedesktop.DBus",
+ 									NULL,
+ 									&error);
+ 	
+ 	if ((proxy == NULL) && (error != NULL)) {
+ 		g_printf("Core error: %s\n", error->message);
+ 		g_error_free(error);
+ 		g_object_unref(connection);
+ 		return FALSE;
+ 	}
+ 	
+ 	error = NULL;
+ 	
+ 	statusv = g_dbus_proxy_call_sync(proxy,
+ 									"StartServiceByName",
+ 									g_variant_new("(su)", interface, 0),
+ 									0,
+ 									-1,
+ 									NULL,
+ 									&error);
+ 	
+ 	if ((statusv == NULL) && (error != NULL)) {
+ 		g_printf("Core error: %s\n", error->message);
+ 		g_error_free(error);
+ 		res = FALSE;
+ 	} else {
+ 		if (status != NULL) {
+ 			g_variant_get(statusv, "(u)", status);
+ 			g_debug("Service start status: %u\n", *status);
+ 		}
+ 		res = TRUE;
+ 	}
+ 	
+ 	g_object_unref(proxy);
+ 	g_object_unref(connection);
+ 	
+ 	return res;
+ }
+ 
  static void mmguicore_system_services_destroy_notify(gpointer data)
  {
  	if (data != NULL) g_free(data);
***************
*** 259,279 ****
  	}
  }
  
! guint mmguicore_modules_enum(mmguicore_t mmguicore)
  {
  	GHashTable *services;
  	guint number = 0;
  	GDir *moddir;
  	const gchar *modname;
  	gsize length;
! 	const gchar modext[] = ".so";
  	gchar *modpath;
  	GModule *module;
  	mmgui_module_init_func module_init;
  	gboolean applicable;
  	struct _mmguimodule smodule, *dmodule;
  		
! 	if (mmguicore == NULL) return 0;
  	
  	services = mmguicore_system_services_enum();
  	
--- 335,390 ----
  	}
  }
  
! static gchar *mmguicore_modules_extract_name(const gchar *filename, gchar *buffer, gsize *bufsize)
! {
! 	gchar *segend, *segstart;
! 	gsize namelen;
! 	
! 	if ((filename == NULL) || (buffer == NULL) || (bufsize == NULL)) return NULL;
! 		
! 	segstart = strchr(filename, MMGUI_MODULE_FILE_PREFIX);
! 	if (segstart != NULL) {
! 		segend = strstr(segstart + 1, MMGUI_MODULE_FILE_EXTENSION);
! 		if (segend != NULL) {
! 			namelen = segend - segstart - 1;
! 			if (namelen != 0) {
! 				if (namelen >= *bufsize) {
! 					namelen = *bufsize - 1;
! 				}
! 				
! 				strncpy(buffer, segstart + 1, namelen);
! 				buffer[namelen] = '\0';
! 				
! 				*bufsize = namelen;
! 				
! 				return buffer;
! 			}
! 		}
! 	} 
! 	
! 	*bufsize = 0;
! 	
! 	return NULL;
! }
! 
! static guint mmguicore_modules_enum(GSList **moduleslist, mmgui_core_options_t options)
  {
  	GHashTable *services;
  	guint number = 0;
  	GDir *moddir;
  	const gchar *modname;
  	gsize length;
! 	const gchar modext[] = MMGUI_MODULE_FILE_EXTENSION;
  	gchar *modpath;
  	GModule *module;
  	mmgui_module_init_func module_init;
+ 	gchar modexname[256];
+ 	gsize modexnamelen;
  	gboolean applicable;
+ 	gboolean recommended;
  	struct _mmguimodule smodule, *dmodule;
  		
! 	if (moduleslist == NULL) return 0;
  	
  	services = mmguicore_system_services_enum();
  	
***************
*** 284,290 ****
  		while ((modname = g_dir_read_name(moddir)) != NULL) {
  			//Test file extension and filename length
  			length = strlen(modname);
! 			if ((length > 3) && (length < 256) && (strncmp((const char *)modname + length - 3, (const char *)&modext, 3) == 0)) {
  				modpath = g_strconcat(RESOURCE_MODULES_DIR, modname, NULL);
  				if (g_file_test(modpath, G_FILE_TEST_EXISTS)) {
  					//Open module
--- 395,401 ----
  		while ((modname = g_dir_read_name(moddir)) != NULL) {
  			//Test file extension and filename length
  			length = strlen(modname);
! 			if ((length > MMGUI_MODULE_FILE_EXTENSION_LEN) && (length < 256) && (strncmp((const gchar *)modname + length - MMGUI_MODULE_FILE_EXTENSION_LEN, (const gchar *)&modext, MMGUI_MODULE_FILE_EXTENSION_LEN) == 0)) {
  				modpath = g_strconcat(RESOURCE_MODULES_DIR, modname, NULL);
  				if (g_file_test(modpath, G_FILE_TEST_EXISTS)) {
  					//Open module
***************
*** 293,304 ****
--- 404,445 ----
  						//Call init function
  						if (g_module_symbol(module, "mmgui_module_init", (gpointer*)&module_init)) {
  							if (module_init(&smodule)) {
+ 								/*Test if module is recommended*/
+ 								recommended = FALSE;
+ 								modexnamelen = sizeof(modexname);
+ 								if ((options != NULL) && (mmguicore_modules_extract_name(modname, modexname, &modexnamelen) != NULL)) {
+ 									switch (smodule.type) {
+ 										case MMGUI_MODULE_TYPE_MODEM_MANAGER:
+ 											if (options->mmmodule != NULL) {
+ 												if (strncmp(modexname, options->mmmodule, modexnamelen) == 0) {
+ 													recommended = TRUE;
+ 												}
+ 											}
+ 											break;
+ 										case MMGUI_MODULE_TYPE_CONNECTION_MANGER:
+ 											if (options->cmmodule != NULL) {
+ 												if (strncmp(modexname, options->cmmodule, modexnamelen) == 0) {
+ 													recommended = TRUE;
+ 												}
+ 											}
+ 											break;
+ 										default:
+ 											break;
+ 									}
+ 								}
  								//Test service/file existence
  								applicable = FALSE;
  								switch (smodule.requirement) {
  									case MMGUI_MODULE_REQUIREMENT_SERVICE:
  										if (g_hash_table_lookup(services, smodule.servicename) != NULL) {
+ 											/*Already running - no need to activate*/
  											applicable = TRUE;
+ 										} else if (recommended) {
+ 											/*Try to activate service if recommended*/
+ 											if (mmguicore_system_services_activate(smodule.servicename, NULL)) {
+ 												g_debug("DBus module started: %s (%s)\n", smodule.servicename, modname);
+ 												applicable = TRUE;
+ 											}
  										}
  										break;
  									case MMGUI_MODULE_REQUIREMENT_FILE:
***************
*** 312,330 ****
  									default:
  										break;
  								}
! 								//Add service to list if applicable
  								if (applicable) {
! 									dmodule = g_malloc0(sizeof(struct _mmguimodule));
! 									memcpy(dmodule, &smodule, sizeof(struct _mmguimodule));
! 									strncpy(dmodule->filename, modname, length);
! 									dmodule->filename[length] = '\0';
! 									mmguicore->modules = g_slist_prepend(mmguicore->modules, dmodule);
! 									g_printf("Module applicable: %s (%s)\n", dmodule->description, dmodule->filename);
  									number++;
  								}
  							}
  						}
! 						//Close module
  						g_module_close(module);
  					}
  				}
--- 453,478 ----
  									default:
  										break;
  								}
! 								/*Add service to list*/
! 								dmodule = g_malloc0(sizeof(struct _mmguimodule));
! 								/*Make instant copy*/
! 								memcpy(dmodule, &smodule, sizeof(struct _mmguimodule));
! 								/*Set recommended and applicable flags*/
! 								dmodule->recommended = recommended;
! 								dmodule->applicable = applicable;
! 								/*Correct filename*/
! 								strncpy(dmodule->filename, modname, length);
! 								dmodule->filename[length] = '\0';
! 								/*Add to list*/
! 								*moduleslist = g_slist_prepend(*moduleslist, dmodule);
! 								/*Count applicable modules*/
  								if (applicable) {
! 									g_debug("Module applicable: %s (%s)\n", dmodule->description, dmodule->filename);
  									number++;
  								}
  							}
  						}
! 						/*Close module*/
  						g_module_close(module);
  					}
  				}
***************
*** 335,342 ****
  	}
  	
  	if (number > 0) {
! 		mmguicore->modules = g_slist_sort(mmguicore->modules, mmguicore_modules_sort);
! 		mmguicore->modules = g_slist_reverse(mmguicore->modules);
  	}
  	
  	g_hash_table_destroy(services);
--- 483,490 ----
  	}
  	
  	if (number > 0) {
! 		*moduleslist = g_slist_sort(*moduleslist, mmguicore_modules_sort);
! 		*moduleslist = g_slist_reverse(*moduleslist);
  	}
  	
  	g_hash_table_destroy(services);
***************
*** 565,584 ****
  	mmfound = FALSE;
  	cmfound = FALSE;
  	
  	for (iterator=mmguicore->modules; iterator; iterator=iterator->next) {
  		module = iterator->data;
! 		if ((module->type == MMGUI_MODULE_TYPE_MODEM_MANAGER) && (!mmfound)) {
! 			mmfound = mmguicore_modules_mm_open(mmguicore, module);
! 		} else if ((module->type == MMGUI_MODULE_TYPE_CONNECTION_MANGER) && (!cmfound)) {
! 			cmfound = mmguicore_modules_cm_open(mmguicore, module);
! 		} else if ((mmfound) && (cmfound)) {
  			break;
  		}
  	}
  		
  	return mmfound;
  }
  
  static void mmguicore_devices_free_single(mmguidevice_t device)
  {
  	if (device != NULL) return;
--- 713,784 ----
  	mmfound = FALSE;
  	cmfound = FALSE;
  	
+ 	/*Try to open recommended modules first*/
  	for (iterator=mmguicore->modules; iterator; iterator=iterator->next) {
  		module = iterator->data;
! 		if ((module->applicable) && (module->recommended)) {
! 			if ((module->type == MMGUI_MODULE_TYPE_MODEM_MANAGER) && (!mmfound)) {
! 				mmfound = mmguicore_modules_mm_open(mmguicore, module);
! 			} else if ((module->type == MMGUI_MODULE_TYPE_CONNECTION_MANGER) && (!cmfound)) {
! 				cmfound = mmguicore_modules_cm_open(mmguicore, module);
! 			}
! 		}
! 		if ((mmfound) && (cmfound)) {
  			break;
  		}
  	}
+ 	
+ 	/*If modules not opened use full list*/
+ 	if (!((mmfound) && (cmfound))) {
+ 		for (iterator=mmguicore->modules; iterator; iterator=iterator->next) {
+ 			module = iterator->data;
+ 			if (module->applicable) {
+ 				if ((module->type == MMGUI_MODULE_TYPE_MODEM_MANAGER) && (!mmfound)) {
+ 					mmfound = mmguicore_modules_mm_open(mmguicore, module);
+ 				} else if ((module->type == MMGUI_MODULE_TYPE_CONNECTION_MANGER) && (!cmfound)) {
+ 					cmfound = mmguicore_modules_cm_open(mmguicore, module);
+ 				}
+ 			}
+ 			if ((mmfound) && (cmfound)) {
+ 				break;
+ 			}
+ 		}	
+ 	}
  		
  	return mmfound;
  }
  
+ void mmguicore_modules_list(mmgui_core_options_t options, mmgui_modules_enum_callback callback)
+ {
+ 	GSList *moduleslist;
+ 	GSList *iterator;
+ 	mmguimodule_t module;
+ 	guint mtype;
+ 	gchar modexname[256];
+ 	gsize modexnamelen;
+ 	guint mtypes[2] = {MMGUI_MODULE_TYPE_MODEM_MANAGER, MMGUI_MODULE_TYPE_CONNECTION_MANGER};
+ 		
+ 	if ((options == NULL) || (callback == NULL)) return;
+ 		
+ 	moduleslist = NULL;
+ 	
+ 	if (mmguicore_modules_enum(&moduleslist, options)) {
+ 		for (mtype = 0; mtype < sizeof(mtypes)/sizeof(guint); mtype++) {
+ 			(callback)(mtypes[mtype], NULL, NULL, FALSE);
+ 			for (iterator=moduleslist; iterator; iterator=iterator->next) {
+ 				module = iterator->data;
+ 				if (module->type == mtypes[mtype]) {
+ 					modexnamelen = sizeof(modexname);
+ 					if (mmguicore_modules_extract_name(module->filename, modexname, &modexnamelen) != NULL) {
+ 						(callback)(mtypes[mtype], modexname, module->description, module->applicable);
+ 					}
+ 				}
+ 			}
+ 		}
+ 		g_slist_free(moduleslist);
+ 	}
+ }
+ 
  static void mmguicore_devices_free_single(mmguidevice_t device)
  {
  	if (device != NULL) return;
***************
*** 1737,1745 ****
  	return (mmguicore->interrupt_operation_func)(mmguicore);
  }
  
! mmguicore_t mmguicore_new(mmgui_event_ext_callback callback, mmgui_traffic_limits_t limits, gpointer userdata)
  {
  	mmguicore_t mmguicore;
  	
  	mmguicore = g_new0(struct _mmguicore, 1);
  	//Modules
--- 1937,1946 ----
  	return (mmguicore->interrupt_operation_func)(mmguicore);
  }
  
! mmguicore_t mmguicore_new(mmgui_event_ext_callback callback, mmgui_traffic_limits_t limits, mmgui_core_options_t options, gpointer userdata)
  {
  	mmguicore_t mmguicore;
+ 	const gchar *mmmodule, *cmmodule; 
  	
  	mmguicore = g_new0(struct _mmguicore, 1);
  	//Modules
***************
*** 1794,1799 ****
--- 1995,2002 ----
  	mmguicore->extcb = callback;
  	//Traffic limits
  	mmguicore->limits = limits;
+ 	/*Core options*/
+ 	mmguicore->options = options;
  	//User data pointer
  	mmguicore->userdata = userdata;
  	//Open netlink interface
***************
*** 1801,1807 ****
  	//Create connections hash table
  	mmguicore->connections = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, (GDestroyNotify)mmguicore_connections_hash_destroy);
  	//Enumerate available modules
! 	if (!mmguicore_modules_enum(mmguicore)) {
  		g_free(mmguicore);
  		g_debug("No modules found\n");
  		return NULL;
--- 2004,2010 ----
  	//Create connections hash table
  	mmguicore->connections = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, (GDestroyNotify)mmguicore_connections_hash_destroy);
  	//Enumerate available modules
! 	if (!mmguicore_modules_enum(&(mmguicore->modules), mmguicore->options)) {
  		g_free(mmguicore);
  		g_debug("No modules found\n");
  		return NULL;
diff -crB modem-manager-gui-0.0.16/src/mmguicore.h modem-manager-gui-0.0.16.new/src/mmguicore.h
*** modem-manager-gui-0.0.16/src/mmguicore.h	2013-07-16 14:43:38.000000000 +0400
--- modem-manager-gui-0.0.16.new/src/mmguicore.h	2013-07-28 00:11:00.000000000 +0400
***************
*** 91,96 ****
--- 91,98 ----
  struct _mmguimodule {
  	//module description
  	guint identifier;
+ 	gboolean applicable;
+ 	gboolean recommended;
  	enum _mmgui_module_type type;
  	enum _mmgui_module_requirement requirement;
  	enum _mmgui_module_priority priority;
***************
*** 102,107 ****
--- 104,112 ----
  
  typedef struct _mmguimodule *mmguimodule_t;
  
+ /*Modules enumeration callback*/
+ typedef void (*mmgui_modules_enum_callback)(enum _mmgui_module_type type, gchar *name, gchar *description, gboolean applicable);
+ 
  enum _mmgui_device_types {
  	MMGUI_DEVICE_TYPE_GSM = 1,
  	MMGUI_DEVICE_TYPE_CDMA
***************
*** 328,333 ****
--- 333,345 ----
  
  typedef struct _mmgui_traffic_stats *mmgui_traffic_stats_t;
  
+ struct _mmgui_core_options {
+ 	gchar *mmmodule;
+ 	gchar *cmmodule;
+ };
+ 
+ typedef struct _mmgui_core_options *mmgui_core_options_t;
+ 
  struct _mmguidevice {
  	guint id;
  	/*State*/
***************
*** 471,476 ****
--- 483,490 ----
  	mmgui_event_ext_callback extcb;
  	//Traffic limits
  	mmgui_traffic_limits_t limits;
+ 	/*Core options*/
+ 	mmgui_core_options_t options;
  	//User data pointer
  	gpointer userdata;
  	//Netlink interface
***************
*** 490,498 ****
  
  typedef struct _mmguicore *mmguicore_t;
  
  //Devices
  gboolean mmguicore_devices_open(mmguicore_t mmguicore, guint deviceid, gboolean openfirst);
- 
  gboolean mmguicore_devices_enable(mmguicore_t mmguicore, gboolean enabled);
  GSList *mmguicore_devices_get_list(mmguicore_t mmguicore);
  mmguidevice_t mmguicore_devices_get_current(mmguicore_t mmguicore);
--- 504,513 ----
  
  typedef struct _mmguicore *mmguicore_t;
  
+ /*Modules*/
+ void mmguicore_modules_list(mmgui_core_options_t options, mmgui_modules_enum_callback callback);
  //Devices
  gboolean mmguicore_devices_open(mmguicore_t mmguicore, guint deviceid, gboolean openfirst);
  gboolean mmguicore_devices_enable(mmguicore_t mmguicore, gboolean enabled);
  GSList *mmguicore_devices_get_list(mmguicore_t mmguicore);
  mmguidevice_t mmguicore_devices_get_current(mmguicore_t mmguicore);
***************
*** 543,549 ****
  gchar *mmguicore_get_last_error(mmguicore_t mmguicore);
  gchar *mmguicore_get_last_connection_error(mmguicore_t mmguicore);
  gboolean mmguicore_interrupt_operation(mmguicore_t mmguicore);
! mmguicore_t mmguicore_new(mmgui_event_ext_callback callback, mmgui_traffic_limits_t limits, gpointer userdata);
  void mmguicore_close(mmguicore_t mmguicore);
  
  #endif /* __MMGUICORE_H__ */
--- 558,564 ----
  gchar *mmguicore_get_last_error(mmguicore_t mmguicore);
  gchar *mmguicore_get_last_connection_error(mmguicore_t mmguicore);
  gboolean mmguicore_interrupt_operation(mmguicore_t mmguicore);
! mmguicore_t mmguicore_new(mmgui_event_ext_callback callback, mmgui_traffic_limits_t limits, mmgui_core_options_t options, gpointer userdata);
  void mmguicore_close(mmguicore_t mmguicore);
  
  #endif /* __MMGUICORE_H__ */
